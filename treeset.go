// Code generated by teaset-gen -pkg teaset -o treeset.go -base TreeSet; DO NOT EDIT THIS FILE

package teaset

import (
	"sync"
)

type TreeSet struct {
	compare func(interface{}, interface{}) int
	eles    []interface{}
	mu      sync.RWMutex
}

func NewTreeSet(compare func(interface{}, interface{}) int) *TreeSet {
	return &TreeSet{compare: compare}
}
func (s *TreeSet) Add(v interface{}) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.add(v)
}
func (s *TreeSet) AddAll(l ...interface{}) {
	s.mu.Lock()
	defer s.mu.Unlock()
	for _, v := range l {
		s.add(v)
	}
}
func (s *TreeSet) add(v interface{}) {
	idx := -1
	for i, ele := range s.eles {
		if s.compare(v, ele) > 0 {
			idx = i
			break
		}
	}
	if idx >= 0 {
		head, tail := s.eles[:idx], s.eles[idx:]
		s.eles = s.eles[:0]
		s.eles = append(s.eles, head...)
		s.eles = append(s.eles, v)
		s.eles = append(s.eles, tail...)
	} else {
		s.eles = append(s.eles, v)
	}
}
func (s *TreeSet) Remove(v interface{}) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.remove(v)
}
func (s *TreeSet) RemoveAll(l ...interface{}) {
	s.mu.Lock()
	defer s.mu.Unlock()
	for _, v := range l {
		s.remove(v)
	}
}
func (s *TreeSet) remove(v interface{}) {
	idx := -1
	for i, ele := range s.eles {
		if s.compare(v, ele) == 0 {
			idx = i
			break
		}
	}
	if idx < 0 {
		return
	}
	head, tail := s.eles[:idx], s.eles[idx+1:]
	s.eles = s.eles[:0]
	s.eles = append(s.eles, head...)
	s.eles = append(s.eles, tail...)
}
func (s *TreeSet) Clear() {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.eles = s.eles[:0]
}
func (s *TreeSet) Contains(v interface{}) bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.contains(v)
}
func (s *TreeSet) ContainsAll(l ...interface{}) bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	for _, v := range l {
		if !s.contains(v) {
			return false
		}
	}
	return true
}
func (s *TreeSet) contains(v interface{}) bool {
	for _, ele := range s.eles {
		if s.compare(v, ele) == 0 {
			return true
		}
	}
	return false
}
func (s *TreeSet) Len() int {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return len(s.eles)
}
func (s *TreeSet) ToSlice() []interface{} {
	s.mu.RLock()
	defer s.mu.RUnlock()
	l := make([]interface{}, len(s.eles))
	for i, v := range s.eles {
		l[i] = v
	}
	return l
}
